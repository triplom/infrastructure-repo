name: Deploy Applications
on:
  # Standard triggers for direct pushes
  push:
    branches:
      - main
    paths:
      - 'apps/**'
      - '.github/workflows/deploy-apps.yaml'
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - qa
          - prod
      application:
        description: 'Application to deploy (empty for all)'
        required: false
        default: ''
  
  # New trigger for cross-repository integration
  repository_dispatch:
    types:
      - app-deployment-request

jobs:
  validate:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      application: ${{ steps.set-app.outputs.application }}
    steps:
      - name: Set Environment
        id: set-env
        run: |
          # For standard trigger or workflow_dispatch
          if [[ "${{ github.event_name }}" != "repository_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment || 'dev' }}" >> $GITHUB_OUTPUT
          else
            # For repository_dispatch
            ENV="${{ github.event.client_payload.environment || 'dev' }}"
            echo "environment=$ENV" >> $GITHUB_OUTPUT
          fi

      - name: Set Application
        id: set-app
        run: |
          # For standard trigger or workflow_dispatch
          if [[ "${{ github.event_name }}" != "repository_dispatch" ]]; then
            echo "application=${{ github.event.inputs.application }}" >> $GITHUB_OUTPUT
          else
            # For repository_dispatch
            APP="${{ github.event.client_payload.app_name }}"
            echo "application=$APP" >> $GITHUB_OUTPUT
          fi
      
      - name: Display Deployment Info
        run: |
          echo "ðŸš€ Deployment request received:"
          echo "â€¢ Environment: ${{ steps.set-env.outputs.environment }}"
          echo "â€¢ Application: ${{ steps.set-app.outputs.application || 'ALL' }}"
          echo "â€¢ Trigger: ${{ github.event_name }}"
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            echo "â€¢ Source Repository: ${{ github.event.client_payload.repository }}"
            echo "â€¢ Version: ${{ github.event.client_payload.version }}"
          fi

  deploy:
    name: Deploy Applications
    needs: validate
    runs-on: self-hosted
    environment: ${{ needs.validate.outputs.environment }}
    env:
      ENV: ${{ needs.validate.outputs.environment }}
      APP: ${{ needs.validate.outputs.application }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Checkout External App Repository
        if: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.repository != '' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.repository }}
          ref: ${{ github.event.client_payload.ref || github.event.client_payload.version || 'main' }}
          path: external-app
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          kustomize-version: "4.5.7"
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.3'
      
      - name: Setup Kubeconfig
        id: kubeconfig
        env:
          ENV: ${{ needs.validate.outputs.environment }}
          # Use environment-specific secrets
          KUBECONFIG_DEV: ${{ secrets.KUBECONFIG_DEV }}
          KUBECONFIG_QA: ${{ secrets.KUBECONFIG_QA }}
          KUBECONFIG_PROD: ${{ secrets.KUBECONFIG_PROD }}
        run: |
          # Select the appropriate KUBECONFIG based on environment
          if [ "$ENV" = "dev" ]; then
            KUBECONFIG_VALUE="$KUBECONFIG_DEV"
            CLUSTER_NAME="kind-dev-cluster"
          elif [ "$ENV" = "qa" ]; then
            KUBECONFIG_VALUE="$KUBECONFIG_QA"
            CLUSTER_NAME="kind-qa-cluster"
          elif [ "$ENV" = "prod" ]; then
            KUBECONFIG_VALUE="$KUBECONFIG_PROD"
            CLUSTER_NAME="kind-prod-cluster"
          else
            echo "::error::Unknown environment: $ENV"
            exit 1
          fi
          
          # Create a temporary file with the secret content
          echo "$KUBECONFIG_VALUE" > encoded_config.txt
          
          # Check if content needs to be decoded or is already in proper format
          if grep -q "apiVersion: v1" encoded_config.txt; then
            echo "Content appears to be in raw YAML format, using as-is"
            cp encoded_config.txt kubeconfig
          else
            echo "Attempting to decode base64 content"
            # Try different decode options with error handling
            if ! base64 -d encoded_config.txt > kubeconfig 2>/dev/null; then
              if ! base64 --decode encoded_config.txt > kubeconfig 2>/dev/null; then
                # If both fail, try a different approach - some systems might have different flags
                cat encoded_config.txt | tr -d '[:space:]' > clean_encoded_config.txt
                if ! base64 -d clean_encoded_config.txt > kubeconfig 2>/dev/null; then
                  if ! base64 --decode clean_encoded_config.txt > kubeconfig 2>/dev/null; then
                    echo "::error::Failed to decode base64 content with standard options"
                    echo "Content format check (first 20 chars):"
                    head -c 20 encoded_config.txt | xxd -p
                    exit 1
                  fi
                fi
              fi
            fi
          fi
          
          # Clean up temporary files
          rm -f encoded_config.txt clean_encoded_config.txt 2>/dev/null || true
          
          # Set proper permissions
          chmod 600 kubeconfig
          
          # Verify kubeconfig content
          if [ ! -s kubeconfig ]; then
            echo "::error::Kubeconfig file is empty after processing"
            exit 1
          fi
          
          # Check if it looks like a valid kubeconfig
          if ! grep -q "apiVersion: v1" kubeconfig; then
            echo "::error::File doesn't appear to be a valid kubeconfig (missing 'apiVersion: v1')"
            echo "First 5 lines of file (sanitized):"
            head -n 5 kubeconfig | sed 's/\(password\|token\|client-key-data\|certificate\|auth-provider\): .*/\1: [REDACTED]/g'
            exit 1
          fi
          
          # Fix TLS verification issues for KIND clusters
          echo "ðŸ”§ Configuring kubeconfig for KIND cluster compatibility"
          
          # Option 1: Disable TLS verification (for development environments)
          if [[ "$ENV" == "dev" || "$ENV" == "qa" ]]; then
            echo "Disabling TLS verification for development/QA environment"
            # Add insecure-skip-tls-verify to the cluster config
            yq eval '.clusters[0].cluster.insecure-skip-tls-verify = true' -i kubeconfig
            # Remove certificate-authority-data if present
            yq eval 'del(.clusters[0].cluster.certificate-authority-data)' -i kubeconfig
          else
            # For production, try to fix certificate issues
            echo "Attempting to fix certificate issues for production environment"
            # Check if we can connect to the cluster directly
            if ! kubectl --kubeconfig=kubeconfig cluster-info &>/dev/null; then
              echo "::warning::Cannot connect with TLS verification, disabling for production as well"
              yq eval '.clusters[0].cluster.insecure-skip-tls-verify = true' -i kubeconfig
              yq eval 'del(.clusters[0].cluster.certificate-authority-data)' -i kubeconfig
            fi
          fi
          
          # Alternative approach: Use kind's direct kubeconfig if available
          if command -v kind &> /dev/null && kind get clusters | grep -q "${CLUSTER_NAME#kind-}"; then
            echo "ðŸ”„ Using direct KIND kubeconfig for better compatibility"
            kind get kubeconfig --name "${CLUSTER_NAME#kind-}" > kind_kubeconfig
            if [ -s kind_kubeconfig ]; then
              mv kind_kubeconfig kubeconfig
              echo "âœ… Using direct KIND kubeconfig"
            fi
          fi
          
          echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
          
          # Test connection
          echo "ðŸ” Testing cluster connection..."
          if kubectl --kubeconfig=kubeconfig cluster-info &>/dev/null; then
            echo "âœ… Successfully connected to cluster"
            kubectl --kubeconfig=kubeconfig get nodes
          else
            echo "::warning::Cluster connection test failed, but continuing..."
            echo "Cluster info attempt:"
            kubectl --kubeconfig=kubeconfig cluster-info || true
          fi
          
          CURRENT_CONTEXT=$(kubectl --kubeconfig=kubeconfig config current-context)
          echo "Using Kubernetes context: $CURRENT_CONTEXT"
          echo "current-context=$CURRENT_CONTEXT" >> $GITHUB_OUTPUT

      - name: Prepare External App (if applicable)
        if: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.repository != '' }}
        run: |
          APP="${{ needs.validate.outputs.application }}"
          APP_VERSION="${{ github.event.client_payload.version }}"
          APP_PATH="external-app"
          ENV="${{ needs.validate.outputs.environment }}"
          
          echo "ðŸ“¦ Preparing external application: $APP"
          echo "ðŸ“‹ Version: $APP_VERSION"
          echo "ðŸŒ Environment: $ENV"
          
          # Ensure app directory structure exists
          mkdir -p "apps/$APP"
          
          # Look for deployment manifests - prioritize k8s directory
          DEPLOY_DIRS=("k8s" "kubernetes" "deploy" "manifests" "deployment")
          FOUND_DEPLOY_DIR=""
          
          echo "ðŸ” Searching for deployment manifests..."
          for dir in "${DEPLOY_DIRS[@]}"; do
            if [ -d "$APP_PATH/$dir" ]; then
              FOUND_DEPLOY_DIR="$APP_PATH/$dir"
              echo "âœ… Found deployment manifests in: $FOUND_DEPLOY_DIR"
              break
            fi
          done
          
          if [ -n "$FOUND_DEPLOY_DIR" ]; then
            echo "ðŸ“‚ Copying manifests from $FOUND_DEPLOY_DIR to apps/$APP"
            
            # Copy the entire k8s directory structure
            cp -r "$FOUND_DEPLOY_DIR"/* "apps/$APP/" 2>/dev/null || {
              echo "::error::Failed to copy deployment files from $FOUND_DEPLOY_DIR"
              exit 1
            }
            
            # Fix filename typos (kustomatization -> kustomization)
            echo "ðŸ”§ Fixing filename typos..."
            find "apps/$APP" -name "kustomatization.yaml" -exec sh -c 'mv "$1" "$(dirname "$1")/kustomization.yaml"' _ {} \; 2>/dev/null || true
            find "apps/$APP" -name "kustomatization.yml" -exec sh -c 'mv "$1" "$(dirname "$1")/kustomization.yml"' _ {} \; 2>/dev/null || true
            
            # Show what we actually copied
            echo "ðŸ“‹ Files copied to apps/$APP:"
            find "apps/$APP" -type f | sort
            
            # Debug: Show content of key files before modification
            echo "ðŸ” Base deployment file content:"
            if [ -f "apps/$APP/base/deployment.yaml" ]; then
              echo "--- apps/$APP/base/deployment.yaml ---"
              head -20 "apps/$APP/base/deployment.yaml"
              echo "--- End of base deployment.yaml (first 20 lines) ---"
            else
              echo "âš ï¸  No deployment.yaml found in base directory"
              ls -la "apps/$APP/base/" || true
            fi
            
            echo "ðŸ” Patch file content:"
            if [ -f "apps/$APP/overlays/$ENV/patches.yaml" ]; then
              echo "--- apps/$APP/overlays/$ENV/patches.yaml ---"
              cat "apps/$APP/overlays/$ENV/patches.yaml"
              echo "--- End of patches.yaml ---"
            else
              echo "âš ï¸  No patches.yaml found"
            fi
            
            # Extract deployment name from base deployment file
            DEPLOYMENT_NAME=""
            if [ -f "apps/$APP/base/deployment.yaml" ]; then
              DEPLOYMENT_NAME=$(grep -A 5 "kind: Deployment" "apps/$APP/base/deployment.yaml" | grep "name:" | head -1 | sed 's/.*name: *//' | tr -d '"' | tr -d "'" | xargs)
              echo "ðŸ“ Found deployment name in base: '$DEPLOYMENT_NAME'"
            else
              echo "âš ï¸  No deployment.yaml found in base, checking for other deployment files"
              # Look for any deployment files
              DEPLOY_FILES=$(find "apps/$APP/base" -name "*.yaml" -exec grep -l "kind: Deployment" {} \; 2>/dev/null || true)
              if [ -n "$DEPLOY_FILES" ]; then
                echo "Found deployment files: $DEPLOY_FILES"
                for file in $DEPLOY_FILES; do
                  DEPLOYMENT_NAME=$(grep -A 5 "kind: Deployment" "$file" | grep "name:" | head -1 | sed 's/.*name: *//' | tr -d '"' | tr -d "'" | xargs)
                  if [ -n "$DEPLOYMENT_NAME" ]; then
                    echo "ðŸ“ Found deployment name in $file: '$DEPLOYMENT_NAME'"
                    break
                  fi
                done
              fi
            fi
            
            # If no deployment found, check if we need to create one
            if [ -z "$DEPLOYMENT_NAME" ]; then
              echo "âš ï¸  No deployment found in base. Creating basic deployment."
              DEPLOYMENT_NAME="k8s-web-app-php"
              
              cat > "apps/$APP/base/deployment.yaml" << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: $DEPLOYMENT_NAME
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: k8s-web-app-php
            template:
              metadata:
                labels:
                  app: k8s-web-app-php
              spec:
                imagePullSecrets:
                  - name: github-registry-secret
                containers:
                  - name: php-fpm
                    image: php-fpm
                    ports:
                      - containerPort: 9000
                    env:
                      - name: APP_ENV
                        value: "$ENV"
                  - name: nginx
                    image: nginx
                    ports:
                      - containerPort: 80
          EOF
              
              # Update base kustomization to include deployment.yaml
              if [ -f "apps/$APP/base/kustomization.yaml" ]; then
                if ! grep -q "deployment.yaml" "apps/$APP/base/kustomization.yaml"; then
                  sed -i '/resources:/a \ \ - deployment.yaml' "apps/$APP/base/kustomization.yaml"
                fi
              else
                cat > "apps/$APP/base/kustomization.yaml" << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          
          resources:
            - deployment.yaml
          
          images:
            - name: php-fpm
              newName: ghcr.io/triplom/k8s-web-app-php/php-fpm
              newTag: $APP_VERSION
            - name: nginx
              newName: ghcr.io/triplom/k8s-web-app-php/nginx
              newTag: $APP_VERSION
          
          commonLabels:
            app: k8s-web-app-php
          EOF
              fi
              
              echo "âœ… Created basic deployment: $DEPLOYMENT_NAME"
            fi
            
            # Fix patch file if it exists and has wrong deployment name
            if [ -f "apps/$APP/overlays/$ENV/patches.yaml" ] && [ -n "$DEPLOYMENT_NAME" ]; then
              echo "ðŸ”§ Validating and fixing patch file"
              
              # Check if patch has the correct deployment name
              PATCH_DEPLOYMENT_NAME=$(grep -A 5 "kind: Deployment" "apps/$APP/overlays/$ENV/patches.yaml" | grep "name:" | head -1 | sed 's/.*name: *//' | tr -d '"' | tr -d "'" | xargs 2>/dev/null || echo "")
              echo "ðŸ“ Found deployment name in patch: '$PATCH_DEPLOYMENT_NAME'"
              
              if [ -n "$PATCH_DEPLOYMENT_NAME" ] && [ "$DEPLOYMENT_NAME" != "$PATCH_DEPLOYMENT_NAME" ]; then
                echo "ðŸ”§ Fixing deployment name mismatch in patches.yaml: '$PATCH_DEPLOYMENT_NAME' -> '$DEPLOYMENT_NAME'"
                sed -i "s/name: $PATCH_DEPLOYMENT_NAME/name: $DEPLOYMENT_NAME/g" "apps/$APP/overlays/$ENV/patches.yaml"
              elif [ -z "$PATCH_DEPLOYMENT_NAME" ]; then
                echo "âš ï¸  Patch file doesn't specify deployment name, adding it"
                # Add name to patch if missing
                sed -i '/kind: Deployment/a \ \ name: '"$DEPLOYMENT_NAME" "apps/$APP/overlays/$ENV/patches.yaml"
              fi
              
              # Show updated patch file
              echo "ðŸ“„ Updated patch file:"
              cat "apps/$APP/overlays/$ENV/patches.yaml"
            elif [ -f "apps/$APP/overlays/$ENV/patches.yaml" ]; then
              echo "âš ï¸  Patch file exists but no deployment name found. Removing patches to avoid errors."
              # Comment out the patches in kustomization to avoid errors
              if [ -f "apps/$APP/overlays/$ENV/kustomization.yaml" ]; then
                sed -i 's/^patchesStrategicMerge:/#patchesStrategicMerge:/' "apps/$APP/overlays/$ENV/kustomization.yaml"
                sed -i 's/^- patches.yaml/#- patches.yaml/' "apps/$APP/overlays/$ENV/kustomization.yaml"
                echo "âœ… Disabled problematic patches in kustomization.yaml"
              fi
            fi
            
            # Replace version placeholders in all yaml files
            echo "ðŸ”„ Updating version tags to: $APP_VERSION"
            find "apps/$APP" -type f \( -name "*.yaml" -o -name "*.yml" \) -exec sed -i "s/\${VERSION}/$APP_VERSION/g" {} \;
            find "apps/$APP" -type f \( -name "*.yaml" -o -name "*.yml" \) -exec sed -i "s/\${TAG}/$APP_VERSION/g" {} \;
            find "apps/$APP" -type f \( -name "*.yaml" -o -name "*.yml" \) -exec sed -i "s/:latest/:$APP_VERSION/g" {} \;
            
            # Update kustomization files with correct image tags
            if [ -f "apps/$APP/overlays/$ENV/kustomization.yaml" ]; then
              echo "ðŸ“ Updating overlay kustomization.yaml with version: $APP_VERSION"
              cd "apps/$APP/overlays/$ENV"
              
              # Use kustomize to update image tags if available
              if command -v kustomize &> /dev/null; then
                echo "Using kustomize to update image tags"
                kustomize edit set image "php-fpm=ghcr.io/triplom/k8s-web-app-php/php-fpm:$APP_VERSION" 2>/dev/null || true
                kustomize edit set image "nginx=ghcr.io/triplom/k8s-web-app-php/nginx:$APP_VERSION" 2>/dev/null || true
              else
                # Fallback: direct sed replacement
                echo "Using sed to update image tags"
                sed -i "s/newTag: .*/newTag: $APP_VERSION/g" kustomization.yaml 2>/dev/null || true
              fi
              
              cd - > /dev/null
            fi
            
            # Test kustomization build to catch errors early
            echo "ðŸ” Testing kustomization build..."
            if [ -d "apps/$APP/overlays/$ENV" ]; then
              cd "apps/$APP/overlays/$ENV"
              
              if command -v kustomize &> /dev/null; then
                if ! kustomize build . > /tmp/kustomize-test.yaml 2>&1; then
                  echo "âš ï¸  Kustomize build failed. Error output:"
                  cat /tmp/kustomize-test.yaml
                  
                  echo "ðŸ”§ Attempting to fix by removing patches..."
                  # Remove patches if they're causing issues
                  sed -i 's/^patchesStrategicMerge:/#patchesStrategicMerge:/' kustomization.yaml 2>/dev/null || true
                  sed -i 's/^- patches.yaml/#- patches.yaml/' kustomization.yaml 2>/dev/null || true
                  
                  # Test again
                  if kustomize build . > /tmp/kustomize-test2.yaml 2>&1; then
                    echo "âœ… Kustomization fixed by removing patches"
                  else
                    echo "âŒ Kustomization still failing:"
                    cat /tmp/kustomize-test2.yaml
                  fi
                else
                  echo "âœ… Kustomization build successful"
                fi
              fi
              
              cd - > /dev/null
            fi
            
          else
            echo "::error::No deployment directory found in external repository"
            echo "Available directories:"
            ls -la "$APP_PATH/"
            exit 1
          fi
          
          # Final verification and display
          echo "ðŸ“‹ Final deployment structure:"
          find "apps/$APP" -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.sh" \) | sort
          
          # Show key files content for debugging
          echo "ðŸ” Final configuration files:"
          
          if [ -f "apps/$APP/base/kustomization.yaml" ]; then
            echo "--- apps/$APP/base/kustomization.yaml ---"
            cat "apps/$APP/base/kustomization.yaml"
            echo "--- End of base kustomization.yaml ---"
          fi
          
          if [ -f "apps/$APP/overlays/$ENV/kustomization.yaml" ]; then
            echo "--- apps/$APP/overlays/$ENV/kustomization.yaml ---"
            cat "apps/$APP/overlays/$ENV/kustomization.yaml"
            echo "--- End of overlay kustomization.yaml ---"
          fi
          
          if [ -f "apps/$APP/overlays/$ENV/patches.yaml" ]; then
            echo "--- apps/$APP/overlays/$ENV/patches.yaml (final) ---"
            cat "apps/$APP/overlays/$ENV/patches.yaml"
            echo "--- End of patches.yaml ---"
          fi
          
          echo "âœ… External app preparation completed"

      - name: Deploy Applications
        run: |
          # Create log directory for deployment logs
          mkdir -p logs
          
          # Function to copy GitHub registry secret from container-auth namespace
          copy_registry_secret() {
            local namespace=$1
            local deploy_log=$2
            local error_log=$3
            
            echo "Copying GitHub Container Registry Secret from container-auth namespace to $namespace" | tee -a "$deploy_log"
            # Check if the secret exists in container-auth namespace
            if kubectl get secret github-registry-secret --namespace=container-auth &>/dev/null; then
              # Copy and modify the secret to the app's namespace
              kubectl get secret github-registry-secret --namespace=container-auth -o yaml | \
                sed "s/namespace: container-auth/namespace: $namespace/" | \
                sed '/creationTimestamp:/d' | \
                sed '/resourceVersion:/d' | \
                sed '/uid:/d' | \
                kubectl apply --validate=false -f - 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
              
              # Important: Wait for the secret to be available in the API server
              echo "Waiting for secret to be available in the API server..." | tee -a "$deploy_log"
              kubectl wait --for=condition=Available --timeout=30s secret/github-registry-secret -n $namespace 2>/dev/null || true
              
              return 0
            else
              echo "::warning::Secret github-registry-secret not found in container-auth namespace" | tee -a "$deploy_log"
              return 1
            fi
          }
          
          # Function to deploy a single app
          deploy_app() {
            local app=$1
            local env=$2
            local deploy_log="logs/deploy-${app}-${env}.log"
            local error_log="logs/error-${app}-${env}.log"
            
            echo "=============================================" | tee -a "$deploy_log"
            echo "Deploying $app to $env environment" | tee -a "$deploy_log"
            echo "Started: $(date)" | tee -a "$deploy_log"
            echo "=============================================" | tee -a "$deploy_log"
            
            # Check if this is an external app deployment
            if [[ "${{ github.event_name }}" == "repository_dispatch" && "$app" == "${{ github.event.client_payload.app_name }}" ]]; then
              local external_deploy=true
              local app_path="external-app"
              
              echo "ðŸ”„ External app deployment detected" | tee -a "$deploy_log"
              
              # If external app has a deploy script, use it
              if [ -f "$app_path/deploy.sh" ]; then
                echo "Using external repository's deploy.sh script" | tee -a "$deploy_log"
                (cd "$app_path" && ./deploy.sh "$env" "${{ github.event.client_payload.version }}") 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
                return $?
              fi
              
              # Check if external app was properly prepared
              if [ ! -d "apps/$app" ]; then
                echo "::warning::External app not found in apps directory, checking external-app directly" | tee -a "$deploy_log"
                
                # Try to deploy directly from external-app directory
                local external_k8s_dirs=("kubernetes" "k8s" "deploy" "manifests")
                local found_external_dir=""
                
                for dir in "${external_k8s_dirs[@]}"; do
                  if [ -d "$app_path/$dir/overlays/$env" ] || [ -d "$app_path/$dir/$env" ]; then
                    found_external_dir="$app_path/$dir"
                    echo "Found deployment directory: $found_external_dir" | tee -a "$deploy_log"
                    break
                  fi
                done
                
                if [ -n "$found_external_dir" ]; then
                  echo "Deploying directly from external repository" | tee -a "$deploy_log"
                  
                  # Create namespace
                  kubectl create namespace $app-$env --dry-run=client -o yaml | kubectl apply --validate=false -f - 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
                  
                  # Copy GitHub registry secret
                  copy_registry_secret "$app-$env" "$deploy_log" "$error_log"
                  
                  # Deploy directly from external repo
                  if [ -d "$found_external_dir/overlays/$env" ]; then
                    echo "Using Kustomize overlay from external repo: $found_external_dir/overlays/$env" | tee -a "$deploy_log"
                    kubectl apply --validate=false -k "$found_external_dir/overlays/$env" 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
                    if [ ${PIPESTATUS[0]} -ne 0 ]; then
                      echo "::error::Failed to deploy $app with external Kustomize" | tee -a "$error_log"
                      return 1
                    fi
                  elif [ -d "$found_external_dir/$env" ]; then
                    echo "Using plain YAML files from external repo: $found_external_dir/$env" | tee -a "$deploy_log"
                    kubectl apply --validate=false -f "$found_external_dir/$env" 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
                    if [ ${PIPESTATUS[0]} -ne 0 ]; then
                      echo "::error::Failed to deploy $app with external YAML" | tee -a "$error_log"
                      return 1
                    fi
                  fi
                else
                  echo "::error::No deployment directory found in external repository" | tee -a "$error_log"
                  return 1
                fi
              fi
            fi
            
            # Standard deployment logic for apps in infrastructure repo
            if [ ! -d "apps/$app" ]; then
              echo "::error::Application directory not found: apps/$app" | tee -a "$error_log"
              return 1
            fi
            
            echo "ðŸ“ Found app directory: apps/$app" | tee -a "$deploy_log"
            echo "ðŸ“‹ Contents:" | tee -a "$deploy_log"
            ls -la "apps/$app/" | tee -a "$deploy_log"
            
            # Deployment methods in order of preference
            
            # 1. Check if app has its own deploy script
            if [ -f "apps/$app/deploy.sh" ]; then
              echo "Found app-specific deploy script" | tee -a "$deploy_log"
              chmod +x "apps/$app/deploy.sh"
              (cd "apps/$app" && ./deploy.sh "$env") 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
              return $?
            fi
            
            # 2. Helm chart detection
            if [ -d "apps/$app/chart" ] || [ -f "apps/$app/Chart.yaml" ]; then
              echo "Detected Helm chart" | tee -a "$deploy_log"
              
              # Create namespace
              kubectl create namespace $app-$env --dry-run=client -o yaml | kubectl apply --validate=false -f - 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
              
              # Copy GitHub registry secret from container-auth namespace
              copy_registry_secret "$app-$env" "$deploy_log" "$error_log"
              
              # Determine chart path
              local chart_path="apps/$app"
              if [ -d "apps/$app/chart" ]; then
                chart_path="apps/$app/chart"
              fi
              
              # Check for env-specific values
              local values_args=""
              if [ -f "apps/$app/values-$env.yaml" ]; then
                values_args="-f apps/$app/values-$env.yaml"
              fi
              
              # Deploy with Helm
              echo "Deploying with Helm" | tee -a "$deploy_log"
              helm upgrade --install "$app" "$chart_path" \
                --namespace "$app-$env" \
                $values_args \
                --atomic \
                --timeout 5m \
                2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
              return $?
            fi
            
            # 3. Kustomize overlay
            if [ -d "apps/$app/overlays/$env" ]; then
              echo "Using Kustomize overlay: apps/$app/overlays/$env" | tee -a "$deploy_log"
              
              # Show what's in the overlay directory
              echo "ðŸ“‹ Overlay directory contents:" | tee -a "$deploy_log"
              ls -la "apps/$app/overlays/$env/" | tee -a "$deploy_log"
              
              # Create namespace if it doesn't exist
              kubectl create namespace $app-$env --dry-run=client -o yaml | kubectl apply --validate=false -f - 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
              
              # Copy GitHub registry secret from container-auth namespace
              copy_registry_secret "$app-$env" "$deploy_log" "$error_log"
              
              # For external apps, we need to handle the deployment differently to preserve relative paths
              if [[ "${{ github.event_name }}" == "repository_dispatch" && "$app" == "${{ github.event.client_payload.app_name }}" ]]; then
                echo "Updating image versions for external app deployment" | tee -a "$deploy_log"
                
                # Check if kustomization file exists
                local kustomization_file="apps/$app/overlays/$env/kustomization.yaml"
                if [ ! -f "$kustomization_file" ]; then
                  echo "::error::kustomization.yaml not found in apps/$app/overlays/$env" | tee -a "$error_log"
                  return 1
                fi
                
                # Create a complete temporary copy of the app directory to preserve relative paths
                local temp_app_dir=$(mktemp -d)
                echo "Creating temporary deployment directory: $temp_app_dir" | tee -a "$deploy_log"
                
                # Copy the entire app structure to temp directory
                cp -r "apps/$app"/* "$temp_app_dir/"
                
                # Update versions in the temporary copy
                find "$temp_app_dir" -type f \( -name "*.yaml" -o -name "*.yml" \) -exec sed -i "s/\${VERSION}/${{ github.event.client_payload.version }}/g" {} \;
                find "$temp_app_dir" -type f \( -name "*.yaml" -o -name "*.yml" \) -exec sed -i "s/:latest/:${{ github.event.client_payload.version }}/g" {} \;
                
                # Update image tags in kustomization files
                if [ -f "$temp_app_dir/overlays/$env/kustomization.yaml" ]; then
                  cd "$temp_app_dir/overlays/$env"
                  
                  # Use kustomize to update image tags if available
                  if command -v kustomize &> /dev/null; then
                    echo "Using kustomize to update image tags" | tee -a "$deploy_log"
                    kustomize edit set image "php-fpm=ghcr.io/triplom/k8s-web-app-php/php-fpm:${{ github.event.client_payload.version }}" 2>/dev/null || true
                    kustomize edit set image "nginx=ghcr.io/triplom/k8s-web-app-php/nginx:${{ github.event.client_payload.version }}" 2>/dev/null || true
                  else
                    # Fallback: direct sed replacement
                    echo "Using sed to update image tags" | tee -a "$deploy_log"
                    sed -i "s/newTag: .*/newTag: ${{ github.event.client_payload.version }}/g" kustomization.yaml 2>/dev/null || true
                  fi
                  
                  # Show the updated kustomization file
                  echo "ðŸ“„ Updated kustomization.yaml:" | tee -a "$deploy_log"
                  cat kustomization.yaml | tee -a "$deploy_log"
                  
                  cd - > /dev/null
                fi
                
                # Apply from the temporary directory (this preserves relative paths)
                echo "Applying kustomization from temporary directory" | tee -a "$deploy_log"
                kubectl apply --validate=false -k "$temp_app_dir/overlays/$env" 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
                local apply_result=${PIPESTATUS[0]}
                
                # Cleanup temporary directory
                rm -rf "$temp_app_dir"
                
                if [ $apply_result -ne 0 ]; then
                  echo "::error::Failed to deploy $app with Kustomize" | tee -a "$error_log"
                  return 1
                fi
              else
                # Standard kustomize apply for internal apps
                kubectl apply --validate=false -k "apps/$app/overlays/$env" 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
                if [ ${PIPESTATUS[0]} -ne 0 ]; then
                  echo "::error::Failed to deploy $app with Kustomize" | tee -a "$error_log"
                  return 1
                fi
              fi
              
            # 4. Plain YAML files
            elif [ -d "apps/$app/$env" ] || [ -d "apps/$app/environments/$env" ]; then
              echo "Using plain YAML files" | tee -a "$deploy_log"
              
              # Determine manifest directory
              local manifest_dir="apps/$app/$env"
              if [ -d "apps/$app/environments/$env" ]; then
                manifest_dir="apps/$app/environments/$env"
              fi
              
              # Create namespace
              kubectl create namespace $app-$env --dry-run=client -o yaml | kubectl apply --validate=false -f - 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
              
              # Copy GitHub registry secret from container-auth namespace
              copy_registry_secret "$app-$env" "$deploy_log" "$error_log"
              
              # Apply all yaml files
              kubectl apply --validate=false -f "$manifest_dir" 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"
              if [ ${PIPESTATUS[0]} -ne 0 ]; then
                echo "::error::Failed to deploy $app with plain YAML" | tee -a "$error_log"
                return 1
              fi
            else
              echo "::error::No supported deployment method found for $app in $env" | tee -a "$error_log"
              echo "Available directories in apps/$app:" | tee -a "$deploy_log"
              ls -la "apps/$app/" | tee -a "$deploy_log"
              return 1
            fi
            
            # Wait for deployments to become ready
            echo "Checking deployments in namespace $app-$env..." | tee -a "$deploy_log"
            DEPLOYMENTS=$(kubectl get deployments -n $app-$env -o name 2>/dev/null || echo "")
            
            if [ -z "$DEPLOYMENTS" ]; then
              echo "::warning::No deployments found for $app in namespace $app-$env" | tee -a "$deploy_log"
              # Show other resources that might have been created
              echo "Resources created:" | tee -a "$deploy_log"
              kubectl get all -n $app-$env | tee -a "$deploy_log"
              return 0
            fi
            
            # Wait for each deployment to roll out
            for DEPLOYMENT in $DEPLOYMENTS; do
              echo "Waiting for rollout of $DEPLOYMENT..." | tee -a "$deploy_log"
              if ! kubectl rollout status $DEPLOYMENT -n $app-$env --timeout=300s 2> >(tee -a "$error_log" >&2) | tee -a "$deploy_log"; then
                echo "::error::Rollout for $DEPLOYMENT failed or timed out" | tee -a "$error_log"
                kubectl get pods -n $app-$env -l app=$app | tee -a "$deploy_log"
                return 1
              fi
            done
            
            echo "âœ… $app successfully deployed to $env" | tee -a "$deploy_log"
            echo "Completed: $(date)" | tee -a "$deploy_log"
            return 0
          }
          
          FAILED_APPS=""
          
          # Deploy either specific app or all apps
          if [ -n "$APP" ]; then
            # Deploy specific app
            if ! deploy_app "$APP" "${ENV}"; then
              echo "::error::Deployment of $APP failed"
              FAILED_APPS="$APP"
            fi
          else
            # Deploy all apps
            for APP_DIR in apps/*/; do
              APP_NAME=$(basename $APP_DIR)
              if ! deploy_app "$APP_NAME" "${ENV}"; then
                FAILED_APPS="$FAILED_APPS $APP_NAME"
                echo "::warning::Failed to deploy $APP_NAME, continuing with others"
              fi
            done
          fi
          
          # Report any failures
          if [ -n "$FAILED_APPS" ]; then
            echo "::error::The following applications failed to deploy:$FAILED_APPS"
            exit 1
          else
            echo "âœ… All requested applications successfully deployed to ${ENV}"
          fi
      
      - name: Upload Deployment Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs-${{ needs.validate.outputs.environment }}
          path: logs/
          retention-days: 7
      
      - name: Cleanup
        if: always()
        run: |
          # Remove any sensitive files
          rm -f $KUBECONFIG